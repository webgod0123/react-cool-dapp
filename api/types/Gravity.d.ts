/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
} from "ethers";
import {
  Contract,
  ContractTransaction,
  Overrides,
  CallOverrides,
} from "@ethersproject/contracts";
import { BytesLike } from "@ethersproject/bytes";
import { Listener, Provider } from "@ethersproject/providers";
import { FunctionFragment, EventFragment, Result } from "@ethersproject/abi";

interface GravityInterface extends ethers.utils.Interface {
  functions: {
    "deployERC20(string,string,string,uint8)": FunctionFragment;
    "lastBatchNonce(address)": FunctionFragment;
    "lastLogicCallNonce(bytes32)": FunctionFragment;
    "sendToCosmos(address,string,uint256)": FunctionFragment;
    "state_gravityId()": FunctionFragment;
    "state_invalidationMapping(bytes32)": FunctionFragment;
    "state_lastBatchNonces(address)": FunctionFragment;
    "state_lastEventNonce()": FunctionFragment;
    "state_lastValsetCheckpoint()": FunctionFragment;
    "state_lastValsetNonce()": FunctionFragment;
    "submitBatch(tuple,tuple[],uint256[],address[],uint256[],uint256,address,uint256)": FunctionFragment;
    "submitLogicCall(tuple,tuple[],tuple)": FunctionFragment;
    "testCheckValidatorSignatures(tuple,tuple[],bytes32,uint256)": FunctionFragment;
    "testMakeCheckpoint(tuple,bytes32)": FunctionFragment;
    "updateValset(tuple,tuple,tuple[])": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "deployERC20",
    values: [string, string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "lastBatchNonce",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "lastLogicCallNonce",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "sendToCosmos",
    values: [string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "state_gravityId",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "state_invalidationMapping",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "state_lastBatchNonces",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "state_lastEventNonce",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "state_lastValsetCheckpoint",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "state_lastValsetNonce",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "submitBatch",
    values: [
      {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      BigNumberish[],
      string[],
      BigNumberish[],
      BigNumberish,
      string,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "submitLogicCall",
    values: [
      {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      {
        transferAmounts: BigNumberish[];
        transferTokenContracts: string[];
        feeAmounts: BigNumberish[];
        feeTokenContracts: string[];
        logicContractAddress: string;
        payload: BytesLike;
        timeOut: BigNumberish;
        invalidationId: BytesLike;
        invalidationNonce: BigNumberish;
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "testCheckValidatorSignatures",
    values: [
      {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      BytesLike,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "testMakeCheckpoint",
    values: [
      {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "updateValset",
    values: [
      {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      { v: BigNumberish; r: BytesLike; s: BytesLike }[]
    ]
  ): string;

  decodeFunctionResult(
    functionFragment: "deployERC20",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "lastBatchNonce",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "lastLogicCallNonce",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "sendToCosmos",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "state_gravityId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "state_invalidationMapping",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "state_lastBatchNonces",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "state_lastEventNonce",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "state_lastValsetCheckpoint",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "state_lastValsetNonce",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "submitBatch",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "submitLogicCall",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "testCheckValidatorSignatures",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "testMakeCheckpoint",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateValset",
    data: BytesLike
  ): Result;

  events: {
    "ERC20DeployedEvent(string,address,string,string,uint8,uint256)": EventFragment;
    "LogicCallEvent(bytes32,uint256,bytes,uint256)": EventFragment;
    "SendToCosmosEvent(address,address,string,uint256,uint256)": EventFragment;
    "TransactionBatchExecutedEvent(uint256,address,uint256)": EventFragment;
    "ValsetUpdatedEvent(uint256,uint256,uint256,address,address[],uint256[])": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "ERC20DeployedEvent"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogicCallEvent"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SendToCosmosEvent"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "TransactionBatchExecutedEvent"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ValsetUpdatedEvent"): EventFragment;
}

export class Gravity extends Contract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  on(event: EventFilter | string, listener: Listener): this;
  once(event: EventFilter | string, listener: Listener): this;
  addListener(eventName: EventFilter | string, listener: Listener): this;
  removeAllListeners(eventName: EventFilter | string): this;
  removeListener(eventName: any, listener: Listener): this;

  interface: GravityInterface;

  functions: {
    deployERC20(
      _cosmosDenom: string,
      _name: string,
      _symbol: string,
      _decimals: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "deployERC20(string,string,string,uint8)"(
      _cosmosDenom: string,
      _name: string,
      _symbol: string,
      _decimals: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    lastBatchNonce(
      _erc20Address: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    "lastBatchNonce(address)"(
      _erc20Address: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    lastLogicCallNonce(
      _invalidation_id: BytesLike,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    "lastLogicCallNonce(bytes32)"(
      _invalidation_id: BytesLike,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    sendToCosmos(
      _tokenContract: string,
      _destination: string,
      _amount: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "sendToCosmos(address,string,uint256)"(
      _tokenContract: string,
      _destination: string,
      _amount: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    state_gravityId(overrides?: CallOverrides): Promise<[string]>;

    "state_gravityId()"(overrides?: CallOverrides): Promise<[string]>;

    state_invalidationMapping(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    "state_invalidationMapping(bytes32)"(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    state_lastBatchNonces(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    "state_lastBatchNonces(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    state_lastEventNonce(overrides?: CallOverrides): Promise<[BigNumber]>;

    "state_lastEventNonce()"(overrides?: CallOverrides): Promise<[BigNumber]>;

    state_lastValsetCheckpoint(overrides?: CallOverrides): Promise<[string]>;

    "state_lastValsetCheckpoint()"(
      overrides?: CallOverrides
    ): Promise<[string]>;

    state_lastValsetNonce(overrides?: CallOverrides): Promise<[BigNumber]>;

    "state_lastValsetNonce()"(overrides?: CallOverrides): Promise<[BigNumber]>;

    submitBatch(
      _currentValset: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      _amounts: BigNumberish[],
      _destinations: string[],
      _fees: BigNumberish[],
      _batchNonce: BigNumberish,
      _tokenContract: string,
      _batchTimeout: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "submitBatch((address[],uint256[],uint256,uint256,address),tuple[],uint256[],address[],uint256[],uint256,address,uint256)"(
      _currentValset: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      _amounts: BigNumberish[],
      _destinations: string[],
      _fees: BigNumberish[],
      _batchNonce: BigNumberish,
      _tokenContract: string,
      _batchTimeout: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    submitLogicCall(
      _currentValset: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      _args: {
        transferAmounts: BigNumberish[];
        transferTokenContracts: string[];
        feeAmounts: BigNumberish[];
        feeTokenContracts: string[];
        logicContractAddress: string;
        payload: BytesLike;
        timeOut: BigNumberish;
        invalidationId: BytesLike;
        invalidationNonce: BigNumberish;
      },
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "submitLogicCall((address[],uint256[],uint256,uint256,address),tuple[],(uint256[],address[],uint256[],address[],address,bytes,uint256,bytes32,uint256))"(
      _currentValset: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      _args: {
        transferAmounts: BigNumberish[];
        transferTokenContracts: string[];
        feeAmounts: BigNumberish[];
        feeTokenContracts: string[];
        logicContractAddress: string;
        payload: BytesLike;
        timeOut: BigNumberish;
        invalidationId: BytesLike;
        invalidationNonce: BigNumberish;
      },
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    testCheckValidatorSignatures(
      _currentValset: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      _theHash: BytesLike,
      _powerThreshold: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    "testCheckValidatorSignatures((address[],uint256[],uint256,uint256,address),tuple[],bytes32,uint256)"(
      _currentValset: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      _theHash: BytesLike,
      _powerThreshold: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    testMakeCheckpoint(
      _valsetArgs: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _gravityId: BytesLike,
      overrides?: CallOverrides
    ): Promise<[void]>;

    "testMakeCheckpoint((address[],uint256[],uint256,uint256,address),bytes32)"(
      _valsetArgs: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _gravityId: BytesLike,
      overrides?: CallOverrides
    ): Promise<[void]>;

    updateValset(
      _newValset: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _currentValset: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "updateValset((address[],uint256[],uint256,uint256,address),(address[],uint256[],uint256,uint256,address),tuple[])"(
      _newValset: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _currentValset: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      overrides?: Overrides
    ): Promise<ContractTransaction>;
  };

  deployERC20(
    _cosmosDenom: string,
    _name: string,
    _symbol: string,
    _decimals: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "deployERC20(string,string,string,uint8)"(
    _cosmosDenom: string,
    _name: string,
    _symbol: string,
    _decimals: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  lastBatchNonce(
    _erc20Address: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "lastBatchNonce(address)"(
    _erc20Address: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  lastLogicCallNonce(
    _invalidation_id: BytesLike,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "lastLogicCallNonce(bytes32)"(
    _invalidation_id: BytesLike,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  sendToCosmos(
    _tokenContract: string,
    _destination: string,
    _amount: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "sendToCosmos(address,string,uint256)"(
    _tokenContract: string,
    _destination: string,
    _amount: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  state_gravityId(overrides?: CallOverrides): Promise<string>;

  "state_gravityId()"(overrides?: CallOverrides): Promise<string>;

  state_invalidationMapping(
    arg0: BytesLike,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "state_invalidationMapping(bytes32)"(
    arg0: BytesLike,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  state_lastBatchNonces(
    arg0: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "state_lastBatchNonces(address)"(
    arg0: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  state_lastEventNonce(overrides?: CallOverrides): Promise<BigNumber>;

  "state_lastEventNonce()"(overrides?: CallOverrides): Promise<BigNumber>;

  state_lastValsetCheckpoint(overrides?: CallOverrides): Promise<string>;

  "state_lastValsetCheckpoint()"(overrides?: CallOverrides): Promise<string>;

  state_lastValsetNonce(overrides?: CallOverrides): Promise<BigNumber>;

  "state_lastValsetNonce()"(overrides?: CallOverrides): Promise<BigNumber>;

  submitBatch(
    _currentValset: {
      validators: string[];
      powers: BigNumberish[];
      valsetNonce: BigNumberish;
      rewardAmount: BigNumberish;
      rewardToken: string;
    },
    _sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
    _amounts: BigNumberish[],
    _destinations: string[],
    _fees: BigNumberish[],
    _batchNonce: BigNumberish,
    _tokenContract: string,
    _batchTimeout: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "submitBatch((address[],uint256[],uint256,uint256,address),tuple[],uint256[],address[],uint256[],uint256,address,uint256)"(
    _currentValset: {
      validators: string[];
      powers: BigNumberish[];
      valsetNonce: BigNumberish;
      rewardAmount: BigNumberish;
      rewardToken: string;
    },
    _sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
    _amounts: BigNumberish[],
    _destinations: string[],
    _fees: BigNumberish[],
    _batchNonce: BigNumberish,
    _tokenContract: string,
    _batchTimeout: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  submitLogicCall(
    _currentValset: {
      validators: string[];
      powers: BigNumberish[];
      valsetNonce: BigNumberish;
      rewardAmount: BigNumberish;
      rewardToken: string;
    },
    _sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
    _args: {
      transferAmounts: BigNumberish[];
      transferTokenContracts: string[];
      feeAmounts: BigNumberish[];
      feeTokenContracts: string[];
      logicContractAddress: string;
      payload: BytesLike;
      timeOut: BigNumberish;
      invalidationId: BytesLike;
      invalidationNonce: BigNumberish;
    },
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "submitLogicCall((address[],uint256[],uint256,uint256,address),tuple[],(uint256[],address[],uint256[],address[],address,bytes,uint256,bytes32,uint256))"(
    _currentValset: {
      validators: string[];
      powers: BigNumberish[];
      valsetNonce: BigNumberish;
      rewardAmount: BigNumberish;
      rewardToken: string;
    },
    _sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
    _args: {
      transferAmounts: BigNumberish[];
      transferTokenContracts: string[];
      feeAmounts: BigNumberish[];
      feeTokenContracts: string[];
      logicContractAddress: string;
      payload: BytesLike;
      timeOut: BigNumberish;
      invalidationId: BytesLike;
      invalidationNonce: BigNumberish;
    },
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  testCheckValidatorSignatures(
    _currentValset: {
      validators: string[];
      powers: BigNumberish[];
      valsetNonce: BigNumberish;
      rewardAmount: BigNumberish;
      rewardToken: string;
    },
    _sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
    _theHash: BytesLike,
    _powerThreshold: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  "testCheckValidatorSignatures((address[],uint256[],uint256,uint256,address),tuple[],bytes32,uint256)"(
    _currentValset: {
      validators: string[];
      powers: BigNumberish[];
      valsetNonce: BigNumberish;
      rewardAmount: BigNumberish;
      rewardToken: string;
    },
    _sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
    _theHash: BytesLike,
    _powerThreshold: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  testMakeCheckpoint(
    _valsetArgs: {
      validators: string[];
      powers: BigNumberish[];
      valsetNonce: BigNumberish;
      rewardAmount: BigNumberish;
      rewardToken: string;
    },
    _gravityId: BytesLike,
    overrides?: CallOverrides
  ): Promise<void>;

  "testMakeCheckpoint((address[],uint256[],uint256,uint256,address),bytes32)"(
    _valsetArgs: {
      validators: string[];
      powers: BigNumberish[];
      valsetNonce: BigNumberish;
      rewardAmount: BigNumberish;
      rewardToken: string;
    },
    _gravityId: BytesLike,
    overrides?: CallOverrides
  ): Promise<void>;

  updateValset(
    _newValset: {
      validators: string[];
      powers: BigNumberish[];
      valsetNonce: BigNumberish;
      rewardAmount: BigNumberish;
      rewardToken: string;
    },
    _currentValset: {
      validators: string[];
      powers: BigNumberish[];
      valsetNonce: BigNumberish;
      rewardAmount: BigNumberish;
      rewardToken: string;
    },
    _sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "updateValset((address[],uint256[],uint256,uint256,address),(address[],uint256[],uint256,uint256,address),tuple[])"(
    _newValset: {
      validators: string[];
      powers: BigNumberish[];
      valsetNonce: BigNumberish;
      rewardAmount: BigNumberish;
      rewardToken: string;
    },
    _currentValset: {
      validators: string[];
      powers: BigNumberish[];
      valsetNonce: BigNumberish;
      rewardAmount: BigNumberish;
      rewardToken: string;
    },
    _sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  callStatic: {
    deployERC20(
      _cosmosDenom: string,
      _name: string,
      _symbol: string,
      _decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "deployERC20(string,string,string,uint8)"(
      _cosmosDenom: string,
      _name: string,
      _symbol: string,
      _decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    lastBatchNonce(
      _erc20Address: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "lastBatchNonce(address)"(
      _erc20Address: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    lastLogicCallNonce(
      _invalidation_id: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "lastLogicCallNonce(bytes32)"(
      _invalidation_id: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    sendToCosmos(
      _tokenContract: string,
      _destination: string,
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "sendToCosmos(address,string,uint256)"(
      _tokenContract: string,
      _destination: string,
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    state_gravityId(overrides?: CallOverrides): Promise<string>;

    "state_gravityId()"(overrides?: CallOverrides): Promise<string>;

    state_invalidationMapping(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "state_invalidationMapping(bytes32)"(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    state_lastBatchNonces(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "state_lastBatchNonces(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    state_lastEventNonce(overrides?: CallOverrides): Promise<BigNumber>;

    "state_lastEventNonce()"(overrides?: CallOverrides): Promise<BigNumber>;

    state_lastValsetCheckpoint(overrides?: CallOverrides): Promise<string>;

    "state_lastValsetCheckpoint()"(overrides?: CallOverrides): Promise<string>;

    state_lastValsetNonce(overrides?: CallOverrides): Promise<BigNumber>;

    "state_lastValsetNonce()"(overrides?: CallOverrides): Promise<BigNumber>;

    submitBatch(
      _currentValset: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      _amounts: BigNumberish[],
      _destinations: string[],
      _fees: BigNumberish[],
      _batchNonce: BigNumberish,
      _tokenContract: string,
      _batchTimeout: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "submitBatch((address[],uint256[],uint256,uint256,address),tuple[],uint256[],address[],uint256[],uint256,address,uint256)"(
      _currentValset: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      _amounts: BigNumberish[],
      _destinations: string[],
      _fees: BigNumberish[],
      _batchNonce: BigNumberish,
      _tokenContract: string,
      _batchTimeout: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    submitLogicCall(
      _currentValset: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      _args: {
        transferAmounts: BigNumberish[];
        transferTokenContracts: string[];
        feeAmounts: BigNumberish[];
        feeTokenContracts: string[];
        logicContractAddress: string;
        payload: BytesLike;
        timeOut: BigNumberish;
        invalidationId: BytesLike;
        invalidationNonce: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<void>;

    "submitLogicCall((address[],uint256[],uint256,uint256,address),tuple[],(uint256[],address[],uint256[],address[],address,bytes,uint256,bytes32,uint256))"(
      _currentValset: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      _args: {
        transferAmounts: BigNumberish[];
        transferTokenContracts: string[];
        feeAmounts: BigNumberish[];
        feeTokenContracts: string[];
        logicContractAddress: string;
        payload: BytesLike;
        timeOut: BigNumberish;
        invalidationId: BytesLike;
        invalidationNonce: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<void>;

    testCheckValidatorSignatures(
      _currentValset: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      _theHash: BytesLike,
      _powerThreshold: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "testCheckValidatorSignatures((address[],uint256[],uint256,uint256,address),tuple[],bytes32,uint256)"(
      _currentValset: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      _theHash: BytesLike,
      _powerThreshold: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    testMakeCheckpoint(
      _valsetArgs: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _gravityId: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    "testMakeCheckpoint((address[],uint256[],uint256,uint256,address),bytes32)"(
      _valsetArgs: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _gravityId: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    updateValset(
      _newValset: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _currentValset: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      overrides?: CallOverrides
    ): Promise<void>;

    "updateValset((address[],uint256[],uint256,uint256,address),(address[],uint256[],uint256,uint256,address),tuple[])"(
      _newValset: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _currentValset: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    ERC20DeployedEvent(
      _cosmosDenom: null,
      _tokenContract: string | null,
      _name: null,
      _symbol: null,
      _decimals: null,
      _eventNonce: null
    ): EventFilter;

    LogicCallEvent(
      _invalidationId: null,
      _invalidationNonce: null,
      _returnData: null,
      _eventNonce: null
    ): EventFilter;

    SendToCosmosEvent(
      _tokenContract: string | null,
      _sender: string | null,
      _destination: null,
      _amount: null,
      _eventNonce: null
    ): EventFilter;

    TransactionBatchExecutedEvent(
      _batchNonce: BigNumberish | null,
      _token: string | null,
      _eventNonce: null
    ): EventFilter;

    ValsetUpdatedEvent(
      _newValsetNonce: BigNumberish | null,
      _eventNonce: null,
      _rewardAmount: null,
      _rewardToken: null,
      _validators: null,
      _powers: null
    ): EventFilter;
  };

  estimateGas: {
    deployERC20(
      _cosmosDenom: string,
      _name: string,
      _symbol: string,
      _decimals: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "deployERC20(string,string,string,uint8)"(
      _cosmosDenom: string,
      _name: string,
      _symbol: string,
      _decimals: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    lastBatchNonce(
      _erc20Address: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "lastBatchNonce(address)"(
      _erc20Address: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    lastLogicCallNonce(
      _invalidation_id: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "lastLogicCallNonce(bytes32)"(
      _invalidation_id: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    sendToCosmos(
      _tokenContract: string,
      _destination: string,
      _amount: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "sendToCosmos(address,string,uint256)"(
      _tokenContract: string,
      _destination: string,
      _amount: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    state_gravityId(overrides?: CallOverrides): Promise<BigNumber>;

    "state_gravityId()"(overrides?: CallOverrides): Promise<BigNumber>;

    state_invalidationMapping(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "state_invalidationMapping(bytes32)"(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    state_lastBatchNonces(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "state_lastBatchNonces(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    state_lastEventNonce(overrides?: CallOverrides): Promise<BigNumber>;

    "state_lastEventNonce()"(overrides?: CallOverrides): Promise<BigNumber>;

    state_lastValsetCheckpoint(overrides?: CallOverrides): Promise<BigNumber>;

    "state_lastValsetCheckpoint()"(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    state_lastValsetNonce(overrides?: CallOverrides): Promise<BigNumber>;

    "state_lastValsetNonce()"(overrides?: CallOverrides): Promise<BigNumber>;

    submitBatch(
      _currentValset: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      _amounts: BigNumberish[],
      _destinations: string[],
      _fees: BigNumberish[],
      _batchNonce: BigNumberish,
      _tokenContract: string,
      _batchTimeout: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "submitBatch((address[],uint256[],uint256,uint256,address),tuple[],uint256[],address[],uint256[],uint256,address,uint256)"(
      _currentValset: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      _amounts: BigNumberish[],
      _destinations: string[],
      _fees: BigNumberish[],
      _batchNonce: BigNumberish,
      _tokenContract: string,
      _batchTimeout: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    submitLogicCall(
      _currentValset: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      _args: {
        transferAmounts: BigNumberish[];
        transferTokenContracts: string[];
        feeAmounts: BigNumberish[];
        feeTokenContracts: string[];
        logicContractAddress: string;
        payload: BytesLike;
        timeOut: BigNumberish;
        invalidationId: BytesLike;
        invalidationNonce: BigNumberish;
      },
      overrides?: Overrides
    ): Promise<BigNumber>;

    "submitLogicCall((address[],uint256[],uint256,uint256,address),tuple[],(uint256[],address[],uint256[],address[],address,bytes,uint256,bytes32,uint256))"(
      _currentValset: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      _args: {
        transferAmounts: BigNumberish[];
        transferTokenContracts: string[];
        feeAmounts: BigNumberish[];
        feeTokenContracts: string[];
        logicContractAddress: string;
        payload: BytesLike;
        timeOut: BigNumberish;
        invalidationId: BytesLike;
        invalidationNonce: BigNumberish;
      },
      overrides?: Overrides
    ): Promise<BigNumber>;

    testCheckValidatorSignatures(
      _currentValset: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      _theHash: BytesLike,
      _powerThreshold: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "testCheckValidatorSignatures((address[],uint256[],uint256,uint256,address),tuple[],bytes32,uint256)"(
      _currentValset: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      _theHash: BytesLike,
      _powerThreshold: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    testMakeCheckpoint(
      _valsetArgs: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _gravityId: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "testMakeCheckpoint((address[],uint256[],uint256,uint256,address),bytes32)"(
      _valsetArgs: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _gravityId: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    updateValset(
      _newValset: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _currentValset: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      overrides?: Overrides
    ): Promise<BigNumber>;

    "updateValset((address[],uint256[],uint256,uint256,address),(address[],uint256[],uint256,uint256,address),tuple[])"(
      _newValset: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _currentValset: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      overrides?: Overrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    deployERC20(
      _cosmosDenom: string,
      _name: string,
      _symbol: string,
      _decimals: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "deployERC20(string,string,string,uint8)"(
      _cosmosDenom: string,
      _name: string,
      _symbol: string,
      _decimals: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    lastBatchNonce(
      _erc20Address: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "lastBatchNonce(address)"(
      _erc20Address: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    lastLogicCallNonce(
      _invalidation_id: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "lastLogicCallNonce(bytes32)"(
      _invalidation_id: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    sendToCosmos(
      _tokenContract: string,
      _destination: string,
      _amount: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "sendToCosmos(address,string,uint256)"(
      _tokenContract: string,
      _destination: string,
      _amount: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    state_gravityId(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "state_gravityId()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    state_invalidationMapping(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "state_invalidationMapping(bytes32)"(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    state_lastBatchNonces(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "state_lastBatchNonces(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    state_lastEventNonce(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "state_lastEventNonce()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    state_lastValsetCheckpoint(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "state_lastValsetCheckpoint()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    state_lastValsetNonce(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "state_lastValsetNonce()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    submitBatch(
      _currentValset: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      _amounts: BigNumberish[],
      _destinations: string[],
      _fees: BigNumberish[],
      _batchNonce: BigNumberish,
      _tokenContract: string,
      _batchTimeout: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "submitBatch((address[],uint256[],uint256,uint256,address),tuple[],uint256[],address[],uint256[],uint256,address,uint256)"(
      _currentValset: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      _amounts: BigNumberish[],
      _destinations: string[],
      _fees: BigNumberish[],
      _batchNonce: BigNumberish,
      _tokenContract: string,
      _batchTimeout: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    submitLogicCall(
      _currentValset: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      _args: {
        transferAmounts: BigNumberish[];
        transferTokenContracts: string[];
        feeAmounts: BigNumberish[];
        feeTokenContracts: string[];
        logicContractAddress: string;
        payload: BytesLike;
        timeOut: BigNumberish;
        invalidationId: BytesLike;
        invalidationNonce: BigNumberish;
      },
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "submitLogicCall((address[],uint256[],uint256,uint256,address),tuple[],(uint256[],address[],uint256[],address[],address,bytes,uint256,bytes32,uint256))"(
      _currentValset: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      _args: {
        transferAmounts: BigNumberish[];
        transferTokenContracts: string[];
        feeAmounts: BigNumberish[];
        feeTokenContracts: string[];
        logicContractAddress: string;
        payload: BytesLike;
        timeOut: BigNumberish;
        invalidationId: BytesLike;
        invalidationNonce: BigNumberish;
      },
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    testCheckValidatorSignatures(
      _currentValset: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      _theHash: BytesLike,
      _powerThreshold: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "testCheckValidatorSignatures((address[],uint256[],uint256,uint256,address),tuple[],bytes32,uint256)"(
      _currentValset: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      _theHash: BytesLike,
      _powerThreshold: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    testMakeCheckpoint(
      _valsetArgs: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _gravityId: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "testMakeCheckpoint((address[],uint256[],uint256,uint256,address),bytes32)"(
      _valsetArgs: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _gravityId: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    updateValset(
      _newValset: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _currentValset: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "updateValset((address[],uint256[],uint256,uint256,address),(address[],uint256[],uint256,uint256,address),tuple[])"(
      _newValset: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _currentValset: {
        validators: string[];
        powers: BigNumberish[];
        valsetNonce: BigNumberish;
        rewardAmount: BigNumberish;
        rewardToken: string;
      },
      _sigs: { v: BigNumberish; r: BytesLike; s: BytesLike }[],
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;
  };
}
